<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Shanruo</title>
  <meta name="author" content="shanruo">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Shanruo"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Shanruo" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://ww1.sinaimg.cn/large/6cea169fjw1edgyzma1xcj21kw16ohba.jpg">
		<a href="/">
			<div class="logo">
				<img src="/logo.png" alt="Profile Picture">
			</div>
			<div id="title">Shanruo</div>
		</a>

		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/shanruo" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/2864911012/profile?topnav=1&wvr=6" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2017-05-17T05:58:37.000Z"><a href="/2017/05/17/babel插件开发总结/">Wed, May 17 2017, 1:58:37 pm</a></time>

  
    <h1 class="title"><a href="/2017/05/17/babel插件开发总结/">babel插件开发总结</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>相信目前常与 ES6 代码打交道的同学对 Babel 应该不会陌生，在 ES6 代码被编译转化为 ES5 代码的过程中，Babel 插件显得尤为重要，Babel 是一个通用的多功能的 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”，意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p>
<p>此外它还拥有众多模块可用于不同形式的静态分析，我们最后经由 Babel 生成的代码取决于插件在这一层中做了什么事，在探索这其中的过程之前，我们先来了解下一些所需的基础知识。</p>
<h1 id="2-基础"><a href="#2-基础" class="headerlink" title="2 基础"></a>2 基础</h1><h2 id="2-1-静态分析"><a href="#2-1-静态分析" class="headerlink" title="2.1 静态分析"></a>2.1 静态分析</h2><p>静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析），静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。</p>
<h2 id="2-2-抽象语法树"><a href="#2-2-抽象语法树" class="headerlink" title="2.2 抽象语法树"></a>2.2 抽象语法树</h2><p>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate），这个处理过程中的每一步都涉及到创建或是操作抽象语法树，亦称 AST。</p>
<p>Babel 的工作流可以用下面一张图来表示，代码首先经由 babylon 解析成抽象语法树（AST），后经一些遍历和分析转换（主要过程），最后根据转换后的 AST 生成新的常规代码。</p>
<p><img src="/image/20170517babel/babelplugin.png"></p>
<p>babylon AST文档可以参考<a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">这里</a>，这个文档对每个节点类型都做了详细的说明，你可以对照各个节点类型在这查找到所需要的信息。</p>
<h2 id="2-3-遍历节点"><a href="#2-3-遍历节点" class="headerlink" title="2.3 遍历节点"></a>2.3 遍历节点</h2><p>在插件里进行节点遍历需要先了解 visitor 和 path 的概念，前者相当于从众多节点类型中选择开发者所需要的节点，后者相当于对节点之间的关系的访问。</p>
<h3 id="2-3-1-visitor"><a href="#2-3-1-visitor" class="headerlink" title="2.3.1 visitor"></a>2.3.1 visitor</h3><p>visitor是一个用于 AST 遍历的跨语言的模式,简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。</p>
<p>比如我只想访问 if…else 生成的节点，我们可以在 visitor 里指定获取它所对应的节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> visitor = &#123;</div><div class="line">  IfStatement() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'get if'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实上述遍历会让每个节点都被访问两次，一次是向下遍历代表进入（enter），一次是向上退出（exit）。因此实际上每个节点都会有 enter 和 exit 方法，在实际操作的时候需要注意这种遍历方式可能会引起的一些问题，上述例子是省略掉 enter 的简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> visitor = &#123;</div><div class="line">  <span class="attr">IfStatement</span>: &#123;</div><div class="line">    enter() &#123;&#125;,</div><div class="line">    exit() &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-2-path"><a href="#2-3-2-path" class="headerlink" title="2.3.2 path"></a>2.3.2 path</h3><p>AST 通常会有许多节点，那么节点直接如何相互关联？</p>
<p>Path 是一个对象，它表示两个节点之间的连接。通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法（类似 DOM 的操作）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyVisitor = &#123;</div><div class="line">  Identifier(path) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Visiting: "</span> + path.node.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="3-基于AST实现代码注入（-alife-doctor-code-inject）"><a href="#3-基于AST实现代码注入（-alife-doctor-code-inject）" class="headerlink" title="3 基于AST实现代码注入（@alife/doctor-code-inject）"></a>3 基于AST实现代码注入（@alife/doctor-code-inject）</h1><p>此插件主要用在实现基于Relim的构建式开发模式中，将生成代码注入react代码模板中。</p>
<p>tnpm：<a href="http://web.npm.alibaba-inc.com/package/@alife/doctor-code-inject" target="_blank" rel="external">http://web.npm.alibaba-inc.com/package/@alife/doctor-code-inject</a></p>
<h2 id="3-1-实现功能"><a href="#3-1-实现功能" class="headerlink" title="3.1 实现功能"></a>3.1 实现功能</h2><h3 id="3-1-1-支持批量插入classMethod"><a href="#3-1-1-支持批量插入classMethod" class="headerlink" title="3.1.1 支持批量插入classMethod"></a>3.1.1 支持批量插入classMethod</h3><p><strong>API</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insertCodeToScript(originCode, insert)</div></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>默认值 </th>
</tr>
</thead>
<tbody>
<tr>
<td>originCode</td>
<td>初始代码</td>
<td>String</td>
<td>无默认，必传，required  </td>
</tr>
<tr>
<td>insert</td>
<td>批量插入的方法</td>
<td>Array</td>
<td>无默认，必传，required</td>
</tr>
</tbody>
</table>
<p><strong>insert实例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> insert = [&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'render'</span>,<span class="comment">// 方法名</span></div><div class="line">    body: render,<span class="comment">// 插入的代码</span></div><div class="line">    isCover: <span class="literal">true</span> <span class="comment">// 是否强制覆盖，默认不覆盖，设置为true则强制覆盖</span></div><div class="line">&#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'add'</span>,</div><div class="line">    <span class="attr">argv</span>: [<span class="string">'c'</span>, <span class="string">'d'</span>], <span class="comment">// 方法传入的参数，会自动检测参数是否已经被定义</span></div><div class="line">    body: add</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>关键实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  批量插入ClassMethod、在组件顶部插入引用代码</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCodeToScript</span>(<span class="params">originCode, insert</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> ast = util.parse2AST(originCode);</div><div class="line">    Traverse(ast, &#123;</div><div class="line">        ClassBody(path) &#123;</div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(insert)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'插入字段类型必须为数组'</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> insert) &#123;</div><div class="line">                <span class="keyword">const</span> methodObj = insert[key],</div><div class="line">                    name = methodObj.name,</div><div class="line">                    argv = methodObj.argv,</div><div class="line">                    body = methodObj.body,</div><div class="line">                    isCover = methodObj.isCover;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> name !== <span class="string">'string'</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'方法名必须为字符串'</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> newAst = util.getTemplateAst(body, &#123;</div><div class="line">                    <span class="attr">sourceType</span>: <span class="string">"script"</span></div><div class="line">                &#125;);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> isExist = util.overideSameMethod(name, path, isCover);</div><div class="line">                <span class="keyword">if</span> (isExist &amp;&amp; !isCover) &#123;</div><div class="line">                    <span class="built_in">console</span>.log(logSymbols.warning, (<span class="string">'方法'</span> + name + <span class="string">'()已经存在，如果要强制覆盖，请设置参数isCover: true'</span>).yellow);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">const</span> params = util.checkParams(argv, newAst);</div><div class="line">                <span class="keyword">const</span> property = Types.ClassMethod(<span class="string">'method'</span>, Types.identifier(name), params, Types.BlockStatement(newAst));</div><div class="line">                path.node.body.push(property);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> generator(ast).code;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-1-2-支持在文件最顶部注入引用代码"><a href="#3-1-2-支持在文件最顶部注入引用代码" class="headerlink" title="3.1.2 支持在文件最顶部注入引用代码"></a>3.1.2 支持在文件最顶部注入引用代码</h3><p><strong>API</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insertImportCode(originCode, importsCode)</div></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>默认值 </th>
</tr>
</thead>
<tbody>
<tr>
<td>originCode</td>
<td>初始代码</td>
<td>String</td>
<td>无默认，必传，required  </td>
</tr>
<tr>
<td>importsCode</td>
<td>插入引用代码</td>
<td>String</td>
<td>无默认，必传，required</td>
</tr>
</tbody>
</table>
<p><strong>关键实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  向js文件顶部插入组件引入代码</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertImportCode</span>(<span class="params">originCode, importsCode</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> ast = util.parse2AST(originCode);</div><div class="line">    Traverse(ast, &#123;</div><div class="line">        <span class="attr">Program</span>: &#123;</div><div class="line">            <span class="attr">exit</span>: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (importsCode) &#123;</div><div class="line">                    <span class="keyword">const</span> importAst = util.getTemplateAst(importsCode, &#123;</div><div class="line">                        <span class="attr">sourceType</span>: <span class="string">'module'</span></div><div class="line">                    &#125;);</div><div class="line">                    path.unshiftContainer(<span class="string">'body'</span>, importAst)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> generator(ast).code;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-1-3-支持批量往方法中注入代码"><a href="#3-1-3-支持批量往方法中注入代码" class="headerlink" title="3.1.3 支持批量往方法中注入代码"></a>3.1.3 支持批量往方法中注入代码</h3><p><strong>API</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insertCodeToMethod(originCode, injectCode)</div></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>默认值 </th>
</tr>
</thead>
<tbody>
<tr>
<td>originCode</td>
<td>初始代码</td>
<td>String</td>
<td>无默认，必传，required</td>
</tr>
<tr>
<td>injectCode</td>
<td>批量往方法插入的代码</td>
<td>Array</td>
<td>无默认，必传，required</td>
</tr>
</tbody>
</table>
<p><strong>injectCode实例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> injectCode = [&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'constructor'</span>,<span class="comment">// 要插入代码的方法名</span></div><div class="line">    code: insertCodeNext,<span class="comment">// 要插入的代码</span></div><div class="line">&#125;,&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'render'</span>,</div><div class="line">    <span class="attr">code</span>: insertCodePrev,</div><div class="line">    <span class="attr">pos</span>: <span class="string">'prev'</span><span class="comment">// 默认是插入在方法块的最后面，配置成'prev',则插入在方法块的最前面</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>关键实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  向方法里面插入代码</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCodeToMethod</span>(<span class="params">originCode, injectCode</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> ast = util.parse2AST(originCode);</div><div class="line">    Traverse(ast, &#123;</div><div class="line">        ClassMethod(path) &#123;</div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(injectCode)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'插入字段类型必须为数组'</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">const</span> methodName = path.get(<span class="string">'body'</span>).container.key.name;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> injectCode) &#123;</div><div class="line">                <span class="keyword">const</span> inject = injectCode[key],</div><div class="line">                    name = inject.name,</div><div class="line">                    code = inject.code,</div><div class="line">                    pos = inject.pos;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> newAst = util.getTemplateAst(code, &#123;</div><div class="line">                    <span class="attr">sourceType</span>: <span class="string">"script"</span></div><div class="line">                &#125;);</div><div class="line">                <span class="keyword">if</span> (methodName === name) &#123;</div><div class="line">                    <span class="keyword">if</span> (pos === <span class="string">'prev'</span>) &#123;</div><div class="line">                        <span class="built_in">Array</span>.prototype.unshift.apply(path.node.body.body, newAst);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="built_in">Array</span>.prototype.push.apply(path.node.body.body, newAst);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> generator(ast).code;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-Util"><a href="#3-2-Util" class="headerlink" title="3.2 Util"></a>3.2 Util</h2><h3 id="3-2-1-parse2AST"><a href="#3-2-1-parse2AST" class="headerlink" title="3.2.1 parse2AST"></a>3.2.1 parse2AST</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  code转化成对应的抽象语法树（AST）</div><div class="line"> */</div><div class="line">exports.parse2AST = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> babylon.parse(content, &#123;</div><div class="line">        <span class="attr">sourceType</span>: <span class="string">'module'</span>,</div><div class="line">        <span class="attr">plugins</span>: [</div><div class="line">            <span class="string">'asyncFunctions'</span>,</div><div class="line">            <span class="string">'classConstructorCall'</span>,</div><div class="line">            <span class="string">'jsx'</span>,</div><div class="line">            <span class="string">'flow'</span>,</div><div class="line">            <span class="string">'trailingFunctionCommas'</span>,</div><div class="line">            <span class="string">'doExpressions'</span>,</div><div class="line">            <span class="string">'objectRestSpread'</span>,</div><div class="line">            <span class="string">'decorators'</span>,</div><div class="line">            <span class="string">'classProperties'</span>,</div><div class="line">            <span class="string">'exportExtensions'</span>,</div><div class="line">            <span class="string">'exponentiationOperator'</span>,</div><div class="line">            <span class="string">'asyncGenerators'</span>,</div><div class="line">            <span class="string">'functionBind'</span>,</div><div class="line">            <span class="string">'functionSent'</span></div><div class="line">        ]</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-2-getTemplateAst"><a href="#3-2-2-getTemplateAst" class="headerlink" title="3.2.2 getTemplateAst"></a>3.2.2 getTemplateAst</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  将模板字符串生成为AST</div><div class="line"> */</div><div class="line">exports.getTemplateAst = <span class="function"><span class="keyword">function</span>(<span class="params">tpl, opts = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> ast = babel.template(tpl, opts)(&#123;&#125;);</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(ast)) &#123;</div><div class="line">        <span class="keyword">let</span> arrAst = [];</div><div class="line">        arrAst.push(ast);</div><div class="line">        <span class="keyword">return</span> arrAst;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> ast;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过编写 Babel 插件，对 AST 有了一定的了解，而且现阶段 Babel 插件不仅仅止于对 ES6 代码的转换上，npm 上有一系列的插件覆盖了许多适合的应用场景，后续具有一定的探索性。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/brigand/babel-plugin-handbook/blob/master/translations/zh-Hans/README.md" target="_blank" rel="external">Babel插件开发指南中文手册</a></li>
<li><a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">Babylon AST文档</a></li>
</ul>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2017/05/17/babel插件开发总结/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://shanruo.github.io/2017/05/17/babel插件开发总结/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2017/05/17/babel插件开发总结/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2017-03-14T06:33:37.000Z"><a href="/2017/03/14/react学习总结/">Tue, Mar 14 2017, 2:33:37 pm</a></time>

  
    <h1 class="title"><a href="/2017/03/14/react学习总结/">react学习总结</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>React 众多优秀特征中的其中一部分就是，教会你去重新思考如何构建应用程序。<br>React 把用户界面当作简单状态机。把用户界面想像成拥有不同状态然后渲染这些状态，可以轻松让用户界面和数据保持一致。</p>
<p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。React 来决定如何最高效地更新 DOM。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>安全性：React 是安全的，不生成 HTML 字符串，因此默认阻止了 XSS 攻击。</li>
<li>组件通信：props 是不可变的，它们从父节点传递过来，被父节点“拥有”。为了实现交互，可以给组件引进可变的 state，this.state 是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己</li>
<li>事件命名：React使用驼峰命名规范的方式给组件绑定事件处理器</li>
<li>refs：利用ref属性给子组件命名，this.refs引用组件。可以在组件上调用getDOMNode()获取浏览器本地的DOM元素</li>
<li>一个限制: React 组件只能渲染单个根节点。如果你想要返回多个节点，它们必须被包含在同一个节点里</li>
<li>如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。以 aria- 开头的 [网络无障碍] 属性可以正常使用。</li>
</ul>
<h3 id="state工作原理"><a href="#state工作原理" class="headerlink" title="state工作原理"></a>state工作原理</h3><p>常用的通知 React 数据变化的方法是调用 setState(data, callback)。这个方法会合并（merge） data 到 this.state，并重新渲染组件。渲染完成后，调用可选的 callback 回调。大部分情况下不需要提供 callback，因为 React 会负责把界面更新到最新状态。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。React 可以用来做简单的 JSX 句法转换。</p>
<p>React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myDivElement = &lt;div className=&quot;foo&quot; /&gt;;</div><div class="line">React.render(myDivElement, document.body);</div></pre></td></tr></table></figure>
<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var MyComponent = React.createClass(&#123;/*...*/&#125;);</div><div class="line">var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;</div><div class="line">React.render(myElement, document.body);</div></pre></td></tr></table></figure>
<p>React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。</p>
<p>注意：由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p>
<h4 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h4><p>要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ({}) 包起来，不要用引号 (“”)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 输入 (JSX):</div><div class="line">var person = &lt;Person name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; /&gt;;</div><div class="line">// 输出 (JS):</div><div class="line">var person = React.createElement(</div><div class="line">  Person,</div><div class="line">  &#123;name: window.isLoggedIn ? window.name : &apos;&apos;&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 {} 包围要注释的部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var content = (</div><div class="line">  &lt;Nav&gt;</div><div class="line">    &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125;</div><div class="line">    &lt;Person</div><div class="line">      /* 多</div><div class="line">         行</div><div class="line">         注释 */</div><div class="line">      name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; // 行尾注释</div><div class="line">    /&gt;</div><div class="line">  &lt;/Nav&gt;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><ul>
<li>getInitialState(): object在组件被挂载之前调用。状态化的组件应该实现这个方法，返回初始的state数据。</li>
<li>componentWillMount()在挂载发生之前立即被调用。</li>
<li>componentDidMount()在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。</li>
</ul>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul>
<li>componentWillReceiveProps(object nextProps)当一个挂载的组件接收到新的props的时候被调用。该方法应该用于比较this.props和nextProps，然后使用this.setState()来改变state。</li>
<li>shouldComponentUpdate(object nextProps, object nextState): boolean当组件做出是否要更新DOM的决定的时候被调用。实现该函数，优化this.props和nextProps，以及this.state和nextState的比较，如果不需要React更新DOM，则返回false。</li>
<li>componentWillUpdate(object nextProps, object nextState)在更新发生之前被调用。你可以在这里调用this.setState()。</li>
<li>componentDidUpdate(object prevProps, object prevState)在更新发生之后调用。</li>
</ul>
<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><ul>
<li>componentWillUnmount()在组件移除和销毁之前被调用。清理工作应该放在这里。</li>
</ul>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2017/03/14/react学习总结/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://shanruo.github.io/2017/03/14/react学习总结/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2017/03/14/react学习总结/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2017-02-27T09:43:13.000Z"><a href="/2017/02/27/插件总是被禁用怎么办？/">Mon, Feb 27 2017, 5:43:13 pm</a></time>

  
    <h1 class="title"><a href="/2017/02/27/插件总是被禁用怎么办？/">插件总是被禁用怎么办？</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>在开发chrome浏览器插件时，总是出现添加了crx扩展程序，重启浏览器就不好使了，各种被禁用，这里有两种普遍情况，一种是上传发布到了应用市场，但是很多用户要直接在应用市场下载是需要翻墙的，只能手动添加打包的crx扩展程序包，但是会被识别非chrome store扩展。</p>
<p><img src="/image/20170227plugin/plugin01.png"></p>
<p>一种是除chrome web store下载的所有第三方扩展，Chrome的新策略里面都禁用了，导致很多插件都没法用，这里给大家就这两种通用情况介绍下解决方案。</p>
<h1 id="已发布chrome应用商店"><a href="#已发布chrome应用商店" class="headerlink" title="已发布chrome应用商店"></a>已发布chrome应用商店</h1><p>针对，已经上传发布的插件应用，用户直接通过chrome网上应用商店需要翻墙。</p>
<p><img src="/image/20170227plugin/plugin02.png"></p>
<p>这就无形之间提升了插件使用的门槛，所以这里主要解决如何提供给用户一个可用又不被禁用的方案。</p>
<p>如果只是单纯的通过浏览器的打包功能打包的crx包文件添加安装，依然会被识别为非chrome store的第三方插件，自然会被禁用，一旦重启浏览器，就用不了。</p>
<p>因此，一定要提供给用户的是从应用商店上下载下来的crx文件，这样就肯定妥妥的没问题。下载方法也很简单，下载地址：<a href="http://chrome-extension-downloader.com/" target="_blank" rel="external">http://chrome-extension-downloader.com/</a><br>这里需要输入要下载的插件的ID，也就是唯一标示。</p>
<p><img src="/image/20170227plugin/plugin03.png"></p>
<p><img src="/image/20170227plugin/plugin04.png"></p>
<p>好了，这样就妥妥的下载了，可以正常使用不被禁用的插件包了，然后再上传到dcms，生成一个下载连接地址，这样就可以对外开放了。</p>
<h1 id="非chrome-store的第三方插件"><a href="#非chrome-store的第三方插件" class="headerlink" title="非chrome store的第三方插件"></a>非chrome store的第三方插件</h1><p>谷歌在2012年Chrome V21+开始禁止第三方扩展静默安装，2014年Chrome V30+开始任何非Chrome 网上应用店(Chrome WebStore)下载的扩展将自动停用。如果自己折腾一个Chrome插件crx打包之后拖进chrome://extensions安装启用一会儿就会被安静的自动停用，自己弄个插件在自己的Chrome浏览器上正常安装&amp;测试都不能够。提交Chrome WebStore审核需要一次性付费5美元，用于验证开发者账户。插件发布审查周期需要等1-3个工作日，更新个插件也要等半小时。一个开发者帐号限制发布最多20个扩展。世界这么大，钱不是问题，可能更想自由些。那么如何解决Chrome浏览器安装任意第三方扩展程序都自动停用的问题呢？</p>
<h2 id="Chrome浏览器扩展程序内置的保护机制"><a href="#Chrome浏览器扩展程序内置的保护机制" class="headerlink" title="Chrome浏览器扩展程序内置的保护机制"></a>Chrome浏览器扩展程序内置的保护机制</h2><p>Chrome内置浏览器安全&amp;隐私保护机制，允许本地用户自定义配置扩展程序相关的安全策略。比如：用户不能安装任何已被列入黑名单的扩展程序（除非它们被加入白名单）。当然也可以通过在ExtensionInstallForcelist中指定扩展程序来强制Google Chrome自动安装这些扩展程序。强制安装列表中的扩展程序均会被安装（无论它们是否包含在黑名单内）。</p>
<ul>
<li>扩展程序安装黑名单(ExtensionInstallBlacklist)</li>
<li>扩展程序安装白名单(ExtensionInstallWhitelist)</li>
<li>强制安装的扩展程序的列表(ExtensionInstallForcelist)</li>
<li>扩展程序、应用和用户脚本安装源(ExtensionInstallSources)</li>
<li>允许的应用/扩展程序类型(ExtensionAllowedTypes)</li>
<li>Ps:优先级&amp;适用范围依次往下逐级递增。</li>
</ul>
<h2 id="方法一：添加指定扩展程序到Chrome白名单"><a href="#方法一：添加指定扩展程序到Chrome白名单" class="headerlink" title="方法一：添加指定扩展程序到Chrome白名单"></a>方法一：添加指定扩展程序到Chrome白名单</h2><p>通过配置扩展程序安装白名单(ExtensionInstallWhitelist)很简单就可以覆盖内置的扩展安装策略，从而正常安装启用指定第三方扩展程序。</p>
<ul>
<li>打开chrome://extensions（扩展程序管理器）页面，拖放xxx.crx上来</li>
<li>按照提示确认安装</li>
<li>提取拓展插件的ID</li>
<li>找到被禁用的扩展，记下ID（设白名单用）</li>
<li>添加指定扩展程序到白名单</li>
</ul>
<h2 id="方法二：使用组策略管理模版"><a href="#方法二：使用组策略管理模版" class="headerlink" title="方法二：使用组策略管理模版"></a>方法二：使用组策略管理模版</h2><p>通过组策略Chrome管理模版，轻松配置Chrome浏览器众多的隐藏内置选项，更高效的使用Chrome，是官方推荐的最简便、可扩展调整的最佳方法。</p>
<ul>
<li>首先下载管理模版并解压到硬盘任意可正常读写访问的地方。</li>
<li>打开运行程序对话框输入：gpedit.msc 打开本地组策略编辑器，在 管理模版 上右键单击添加对应操作系统当前语言的管理模块，这里我们选择zh-CN中chrome.adm安装即可</li>
<li>再展开 计算机配置 -&gt; 管理模板 -&gt; 经典管理模版(ADM) -&gt; Google -&gt; Google Chrome -&gt; 扩展程序</li>
<li>右侧双击打开“配置扩展程序安装白名单” -&gt; 选中“已启用”，点击“显示…” 双击列表中值这一列输入希望安装的第三方扩展程序的唯一ID 确定保存 -&gt; 点击应用 确定，然后退出整个本地组策略编辑器，无需重启Chrome浏览器，只需要重新打开扩展程序管理器就可以直接启用被禁的第三方扩展插件。</li>
</ul>
<p>Tips:嫌逐一的为拓展添加白名单麻烦，配置扩展程序、应用和用户脚本安装源 状态为启用 值为：<all_urls> 应用保存即可。值得一提的是Chrome组策略管理模版里头带了很多高大上的设置，请根据相应的配置提示自行挖掘尝试。</all_urls></p>
<p>如何检查配置的政策是否正确有效？：打开chrome://policy查看相应的策略的状态是否为确定即可。</p>
<p>关于管理策略模板来源以及更具体的使用情况可以访问Chromium官网<a href="http://www.chromium.org/administrators/policy-templates" target="_blank" rel="external">获取更多</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2017/02/27/插件总是被禁用怎么办？/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://shanruo.github.io/2017/02/27/插件总是被禁用怎么办？/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2017/02/27/插件总是被禁用怎么办？/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-10-07T01:31:04.000Z"><a href="/2015/10/07/css动画/">Wed, Oct 7 2015, 9:31:04 am</a></time>

  
    <h1 class="title"><a href="/2015/10/07/css动画/">css动画</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>今天我们一起来学习有关于CSS3制作动画的几个属性：变形（transform）、转换（transition）和动画（animation）等及更高级的CSS3技术。</p>
<h2 id="变形（transform）"><a href="#变形（transform）" class="headerlink" title="变形（transform）"></a>变形（transform）</h2><p>Transform字面上就是变形，改变的意思。在CSS3中transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。下面我们一起来看看CSS3中transform的旋转rotate、扭曲skew、缩放scale和移动translate具体如何实现。<br>语法：</p>
<pre><code>transform ： none | <transform-function> [ <transform-function> ]*
也就是：transform: rotate | scale | skew | translate |matrix;
</transform-function></transform-function></code></pre>

<h3 id="旋转（rotate）"><a href="#旋转（rotate）" class="headerlink" title="旋转（rotate）"></a>旋转（rotate）</h3><p>rotate(<angle>) ：通过指定的角度参数对原元素指定一个2D rotation（2D 旋转），需先有transform-origin属性的定义。transform-origin定义的是旋转的基点，其中angle是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。如：transform:rotate(30deg):<br><img src="/image/20151007css动画/rotate.png" style="margin-left:30%;margin-top:20px;"><br><a href="http://codepen.io/shanruo/pen/BoRPeZ" target="_blank" rel="external">demo</a></angle></p>
<h3 id="移动（translate）"><a href="#移动（translate）" class="headerlink" title="移动（translate）"></a>移动（translate）</h3><p>移动translate我们分为三种情况：translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）；translateX(x)仅水平方向移动（X轴移动）；translateY(Y)仅垂直方向移动（Y轴移动），具体使用方法如下：<br>1、translate(<translation-value>[, <translation-value>]) ：通过矢量[tx, ty]指定一个2D translation，tx 是第一个过渡值参数，ty 是第二个过渡值参数选项。如果 未被提供，则ty以 0 作为其值。也就是translate(x,y),它表示对象进行平移，按照设定的x,y参数值,当值为负数时，反方向移动物体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点。如transform:translate(50px,20px):<br><img src="/image/20151007css动画/translate.png" style="margin-left:30%;margin-top:20px;"><br><a href="http://codepen.io/shanruo/pen/dYWqMM" target="_blank" rel="external">demo</a><br>2、translateX(<translation-value>) ： 通过给定一个X方向上的数目指定一个translation。只向x轴进行移动元素，同样其基点是元素中心点，也可以根据transform-origin改变基点位置。如：transform:translateX(50px).<br>3、translateY(<translation-value>) ：通过给定Y方向的数目指定一个translation。只向Y轴进行移动，基点在元素心点，可以通过transform-origin改变基点位置。如：transform:translateY(20px).</translation-value></translation-value></translation-value></translation-value></p>
<h3 id="缩放（scale）"><a href="#缩放（scale）" class="headerlink" title="缩放（scale）"></a>缩放（scale）</h3><p>缩放scale和移动translate是极其相似，他也具有三种情况：scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；scaleX(x)元素仅水平方向缩放（X轴缩放）；scaleY(y)元素仅垂直方向缩放（Y轴缩放），但它们具有相同的缩放中心点和基数，其中心点就是元素的中心位置，缩放基数为1，如果其值大于1元素就放大，反之其值小于1，元素缩小。下面我们具体来看看这三种情况具体使用方法：<br>1、scale(<number>[, <number>])：提供执行[sx,sy]缩放矢量的两个参数指定一个2D scale（2D缩放）。如果第二个参数未提供，则取与第一个参数一样的值。scale(X,Y)是用于对元素进行缩放，可以通过transform-origin对元素的基点进行设置，同样基点在元素中心位置；基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。如：transform:scale(1.5,1.5):<br><img src="/image/20151007css动画/scale.png" style="margin-left:30%;margin-top:20px;"><br><a href="http://codepen.io/shanruo/pen/NGjLRM" target="_blank" rel="external">demo</a><br>2、scaleX(<number>) ： 使用 [sx,1] 缩放矢量执行缩放操作，sx为所需参数。scaleX表示元素只在X轴(水平方向)缩放元素，他的默认值是(1,1)，其基点一样是在元素的中心位置，我们同样是通过transform-origin来改变元素的基点。如：transform:scaleX(2).<br>3、scaleY(<number>) ： 使用 [1,sy] 缩放矢量执行缩放操作，sy为所需参数。scaleY表示元素只在Y轴（垂直方向）缩放元素，其基点同样是在元素中心位置，可以通过transform-origin来改变元素的基点。如transform:scaleY(2).</number></number></number></number></p>
<h3 id="扭曲（skew）"><a href="#扭曲（skew）" class="headerlink" title="扭曲（skew）"></a>扭曲（skew）</h3><p>扭曲skew和translate、scale一样同样具有三种情况：skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形），具体使用如下：<br>1、skew(<angle> [, <angle>]) ：X轴Y轴上的skew transformation（斜切变换）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。skew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。同样是以元素中心为基点，我们也可以通过transform-origin来改变元素的基点位置。如：transform:skew(30deg,20deg):<br><img src="/image/20151007css动画/skew.png" style="margin-left:30%;margin-top:20px;"><br><a href="http://codepen.io/shanruo/pen/jbmvVv" target="_blank" rel="external">demo</a><br>2、skewX(<angle>) ： 按给定的角度沿X轴指定一个skew transformation（斜切变换）。skewX是使元素以其中心为基点，并在水平方向（X轴）进行扭曲变行，同样可以通过transform-origin来改变元素的基点。如：transform:skewX(30deg).<br>3、skewY(<angle>) ： 按给定的角度沿Y轴指定一个skew transformation（斜切变换）。skewY是用来设置元素以其中心为基点并按给定的角度在垂直方向（Y轴）扭曲变形。同样我们可以通过transform-origin来改变元素的基点。如：transform:skewY(10deg).</angle></angle></angle></angle></p>
<h3 id="矩阵（matrix）"><a href="#矩阵（matrix）" class="headerlink" title="矩阵（matrix）"></a>矩阵（matrix）</h3><p>matrix(number, number, number, number, number, number) ：以一个含六值的(a,b,c,d,e,f)变换矩阵的形式指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果有感兴趣的朋友可以去了解更深层次的martix使用方法，这里就不多说了。<br><strong>tip:</strong><br>transform-origin跟其他的css3属性一样，我们需要在不同的浏览内核中加上相应的前缀，下面列出各种浏览器内核下的语法规则：</p>
<pre><code>
//Mozilla内核浏览器：firefox3.5+
  -moz-transform-origin: x y;
  //Webkit内核浏览器：Safari and Chrome
  -webkit-transform-origin: x y;
  //Opera
  -o-transform-origin: x y ;
  //IE9
  -ms-transform-origin: x y;
  //W3C标准
  transform-origin: x y ;
</code></pre>
transform在不同浏览器内核下的书写规则:
<pre><code>
//Mozilla内核浏览器：firefox3.5+
  -moz-transform: rotate | scale | skew | translate ;
 //Webkit内核浏览器：Safari and Chrome
  -webkit-transform: rotate | scale | skew | translate ;
 //Opera
  -o-transform: rotate | scale | skew | translate ;
 //IE9
  -ms-transform: rotate | scale | skew | translate ;
 //W3C标准
  transform: rotate | scale | skew | translate ;
</code></pre>


<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在上面我们详细介绍了CSS3中transform的各种属性值的设置以及其各自的参数，下面我们通过一个实例来看看每一种属性值的使用，主要是我们在下面的菜单中的a:hover中分别使用不同的transform的设置，换句话说，当你移动到链接上时，相应的每一个菜单项有不同的变化，因为我们在每个菜单中使用了transform。<br>从效果图上我们可以清楚的看到菜单上我们分别对应的是transform中的Translate、TranslateX、TranslateY、Rotate、Scale、ScaleX、ScaleY、Skew、SkewX、SkewY和Matrix.<br>效果：<br><img src="/image/20151007css动画/transform.png" style="margin-top:20px;"><br><a href="http://codepen.io/shanruo/pen/XmRPgr" target="_blank" rel="external">demo</a></p>
<h2 id="转换（transition）"><a href="#转换（transition）" class="headerlink" title="转换（transition）"></a>转换（transition）</h2><p>W3C标准中对css3的transition这是样描述的：“css的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。”<br>下面我们同样从其最语法和属性值开始一步一步来学习transition的具体使用:<br>语法：</p>
<pre><code>
transition ： [<'transition-property'> || <'transition-duration'> || <'transition-timing-function'> || <'transition-delay'> [, [<'transition-property'> || <'transition-duration'> || <'transition-timing-function'> || <'transition-delay'>]]*
</'transition-delay'></'transition-timing-function'></'transition-duration'></'transition-property'></'transition-delay'></'transition-timing-function'></'transition-duration'></'transition-property'></code></pre>

<p>transition主要包含四个属性值：执行变换的属性：transition-property,变换延续的时间：transition-duration,在延续时间段，变换的速率变化transition-timing-function,变换延迟时间transition-delay。下面分别来看这四个属性值:<br>一、transition-property:<br>语法：</p>
<pre><code>
transition-property ： none | all | [ IDENT ] [ ',' IDENT ]*
</code></pre>

<p>transition-property是用来指定当元素其中一个属性改变时执行transition效果，其主要有以下几个值：none(没有属性改变)；all（所有属性改变）这个也是其默认值；indent（元素属性名）。当其值为none时，transition马上停止执行，当指定为all时，则元素产生任何属性值变化时都将执行transition效果，ident是可以指定元素的某一个属性值。其对应的类型如下：<br>1、color: 通过红、绿、蓝和透明度组件变换（每个数值处理）如：background-color,border-color,color,outline-color等css属性；<br>2、length: 真实的数字 如：word-spacing,width,vertical-align,top,right,bottom,left,padding,outline-width,margin,min-width,min-height,max-width,max-height,line-height,height,border-width,border-spacing,background-position等属性；<br>3、percentage:真实的数字 如：word-spacing,width,vertical-align,top,right,bottom,left,min-width,min-height,max-width,max-height,line-height,height,background-position等属性；<br>4、integer离散步骤（整个数字），在真实的数字空间，以及使用floor()转换为整数时发生 如：outline-offset,z-index等属性；<br>5、number真实的（浮点型）数值，如：zoom,opacity,font-weight,等属性；<br>6、transform list:详情请参阅上面的transform介绍<br>7、rectangle:通过x, y, width 和 height（转为数值）变换，如：crop<br>8、visibility: 离散步骤，在0到1数字范围之内，0表示“隐藏”，1表示完全“显示”,如：visibility<br>9、shadow: 作用于color, x, y 和 blur（模糊）属性,如：text-shadow<br>10、gradient: 通过每次停止时的位置和颜色进行变化。它们必须有相同的类型（放射状的或是线性的）和相同的停止数值以便执行动画,如：background-image<br>11、paint server (SVG): 只支持下面的情况：从gradient到gradient以及color到color，然后工作与上面类似<br>12、space-separated list of above:如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化<br>13、a shorthand property: 如果缩写的所有部分都可以实现动画，则会像所有单个属性变化一样变化<br>具体什么css属性可以实现transition效果，在W3C官网中列出了所有可以实现transition效果的CSS属性值以及值的类型，大家可以点<a href="http://www.w3.org/TR/css3-transitions/#properties-from-css-" target="_blank" rel="external">这里</a>了解详情。这里需要提醒一点是，并不是什么属性改变都为触发transition动作效果，比如页面的自适应宽度，当浏览器改变宽度时，并不会触发transition的效果。但上述表格所示的属性类型改变都会触发一个transition动作效果。<br>二、transition-duration:<br>语法：</p>
<p><pre><code><br>transition-duration ： time [, time]*<br></code></pre><br>transition-duration是用来指定元素转换过程的持续时间，取值：<time>为数值，单位为s（秒）或者ms(毫秒),可以作用于所有元素，包括:before和:after伪元素。其默认值是0，也就是变换时是即时的。<br>三、transition-timing-function:<br>语法：</time></p>
<p><pre><code><br>transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(number, number, number, number) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(number, number, number, number)]*<br></code></pre><br>取值：<br>transition-timing-function的值允许你根据时间的推进去改变属性值的变换速率，transition-timing-function有6个可能值：<br>1、ease：（逐渐变慢）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).<br>2、linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0).<br>3、ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0).<br>4、ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0).<br>5、ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)<br>6、cubic-bezier：（该值允许你去自定义一个时间曲线）， 特定的cubic-bezier曲线。 (x1, y1, x2, y2)四个值特定于曲线上点P1和点P2。所有值需在[0, 1]区域内，否则无效。<br>其是cubic-bezier为通过贝赛尔曲线来计算“转换”过程中的属性值，如下曲线所示，通过改变P1(x1, y1)和P2(x2, y2)的坐标可以改变整个过程的Output Percentage。初始默认值为default.</p>
<div><img src="/image/20151007css动画/cubic-bezier.png" style="margin-left:20%;margin-top:20px;"></div><br>其他几个属性的示意图：<br><div><img src="/image/20151007css动画/transitionline.png" style="margin-left:13%;margin-top:20px;"></div><br>四、transition-delay:<br>语法：<br><pre><code><br>transition-delay ： time [, time]*<br></code></pre><br>transition-delay是用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行transition效果，其取值：<time>为数值，单位为s（秒）或者ms(毫秒)，其使用和transition-duration极其相似，也可以作用于所有元素，包括:before和:after伪元素。 默认大小是”0”，也就是变换立即执行，没有延迟。<br>有时我们不只改变一个css效果的属性,而是想改变两个或者多个css属性的transition效果，那么我们只要把几个transition的声明串在一起，用逗号（“，”）隔开，然后各自可以有各自不同的延续时间和其时间的速率变换方式。但需要值得注意的一点：transition-delay与transition-duration的值都是时间，所以要区分它们在连写中的位置，一般浏览器会根据先后顺序决定，第一个可以解析为时间的怭值为transition-duration第二个为transition-delay。如：<br><pre><code><br>a {<br>    -moz-transition: background 0.5s ease-in,color 0.3s ease-out;<br>    -webkit-transition: background 0.5s ease-in,color 0.3s ease-out;<br>    -o-transition: background 0.5s ease-in,color 0.3s ease-out;<br>    transition: background 0.5s ease-in,color 0.3s ease-out;<br>  }<br></code></pre><br>如果你想给元素执行所有transition效果的属性，那么我们还可以利用all属性值来操作，此时他们共享同样的延续时间以及速率变换方式，如：<br><pre><code><br>a {<br>    -moz-transition: all 0.5s ease-in;<br>    -webkit-transition: all 0.5s ease-in;<br>    -o-transition: all 0.5s ease-in;<br>    transition: all 0.5s ease-in;<br>  }<br></code></pre><br>综合上述我们可以给transition一个速记法：transition: <property> <duration> <animation type=""> <delay>如下图所示：<br><div><img src="/image/20151007css动画/transitionmemory.png" style="margin-left:20%;margin-top:20px;"></div>

<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>通过上面，我想大家对CSS3的Transition属性的使用有一定的概念存在了，下面为了加强大家在这方面的使用，我们一起来看下面的DEMO。我们通过实践来巩固前面的理论知识，也通过实践来加强transition的记忆。<br>我们主要是在一个div中放置了几个小块，分别是对应了transition-timing-function中的几种类型，我们在div的hover状态下，改变其部分属性，从而达到一种动画效果。我们也可以使用jq来点击一个按钮，触发这个div（说简单点就是通过按钮的点击事件给这个div加上一个class，让其子元素都触发相对应的transition动画效果）。<br><a href="http://codepen.io/shanruo/pen/NGjLBE" target="_blank" rel="external">DEMO</a></p>
<h2 id="动画（animation）"><a href="#动画（animation）" class="headerlink" title="动画（animation）"></a>动画（animation）</h2><p>在开始介绍Animation之前我们有必要先来了解一个特殊的东西，那就是”Keyframes”,我们把他叫做“关键帧”，玩过flash的朋友可能对这个东西并不会陌生。下面我们就一起来看看这个“Keyframes”是什么东西。前面我们在使用transition制作一个简单的transition效果时，我们包括了初始属性和最终属性，一个开始执行动作时间和一个延续动作时间以及动作的变换速率，其实这些值都是一个中间值，如果我们要控制的更细一些，比如说我要第一个时间段执行什么动作，第二个时间段执行什么动作（换到flash中说，就是第一帧我要执行什么动作，第二帧我要执行什么动作），这样我们用Transition就很难实现了，此时我们也需要这样的一个“关键帧”来控制。那么CSS3的Animation就是由“keyframes”这个属性来实现这样的效果。下面我们一起先来看看Keyframes:</p>
<p>Keyframes具有其自己的语法规则，他的命名是由”@keyframes”开头，后面紧接着是这个“动画的名称”加上一对花括号“{}”，括号中就是一些不同时间段样式规则，有点像我们css的样式写法一样。对于一个”@keyframes”中的样式规则是由多个百分比构成的，如“0%”到”100%”之间，我们可以在这个规则中创建多个百分比，我们分别给每一个百分比中给需要有动画效果的元素加上不同的属性，从而让元素达到一种在不断变化的效果，比如说移动，改变元素颜色，位置，大小，形状等，不过有一点需要注意的是，我们可以使用“fromt”“to”来代表一个动画是从哪开始，到哪结束，也就是说这个 “from”就相当于”0%”而”to”相当于”100%”,值得一说的是，其中”0%”不能像别的属性取值一样把百分比符号省略，我们在这里必须加上百分符号（“%”）如果没有加上的话，我们这个keyframes是无效的，不起任何作用。因为keyframes的单位只接受百分比值。<br>Keyframes可以指定任何顺序排列来决定Animation动画变化的关键位置。其具体语法规则如下：</p>
<p><pre><code><br>keyframes-rule: ‘@keyframes’ IDENT ‘{‘ keyframes-blocks ‘}’;<br> keyframes-blocks: [ keyframe-selectors block ]<em> ;<br> keyframe-selectors: [ ‘from’ | ‘to’ | PERCENTAGE ] [ ‘,’ [ ‘from’ | ‘to’ | PERCENTAGE ] ]</em>;<br></code></pre><br>我们把上面的语法综合起来：</p>
<p><pre><code><br>@keyframes IDENT {<br>     from {<br>       Properties:Properties value;<br>     }<br>     Percentage {<br>       Properties:Properties value;<br>     }<br>     to {<br>       Properties:Properties value;<br>     }<br>   }<br>   或者全部写成百分比的形式：<br>   @keyframes IDENT {<br>      0% {<br>         Properties:Properties value;<br>      }<br>      Percentage {<br>         Properties:Properties value;<br>      }<br>      100% {<br>         Properties:Properties value;<br>      }<br>    }<br></code></pre><br>其中IDENT是一个动画名称，你可以随便取，当然语义化一点更好，Percentage是百分比值，我们可以添加许多个这样的百分比，Properties为css的属性名，比如说left,background等，value就是相对应的属性的属性值。值得一提的是，我们from和to 分别对应的是0%和100%。这个我们在前面也提到过了。到目前为止支技animation动画的只有webkit内核的浏览器，所以我需要在上面的基础上加上-webkit前缀，据说Firefox5可以支持css3的 animation动画属性。<br>我们来看一个W3C官网的实例:</p>
<p><pre><code><br>@-webkit-keyframes ‘wobble’ {<br>     0% {<br>        margin-left: 100px;<br>        background: green;<br>     }<br>     40% {<br>        margin-left: 150px;<br>        background: orange;<br>     }<br>     60% {<br>        margin-left: 75px;<br>        background: blue;<br>     }<br>     100% {<br>        margin-left: 100px;<br>        background: red;<br>     }<br>  }<br></code></pre><br>这里我们定义了一个叫“wobble”的动画，他的动画是从0%开始到100%时结束，从中还经历了一个40%和60%两个过程，上面代码具体意思是：wobble动画在0%时元素定位到left为100px的位置背景色为green，然后40%时元素过渡到left为150px的位置并且背景色为orange，60%时元素过渡到left为75px的位置,背景色为blue，最后100%结束动画的位置元素又回到起点left为100px处,背景色变成red。<br>Keyframes定义好了以后，我们需要怎么去调用刚才定义好的动画“wobble”:<br>CSS3的animation类似于transition属性，他们都是随着时间改变元素的属性值。他们主要区别是transition需要触发一个事件(hover事件或click事件等)才会随时间改变其css属性；而animation在不需要触发任何事件的情况下也可以显式的随着时间变化来改变元素css的属性值，从而达到一种动画的效果。这样我们就可以直接在一个元素中调用animation的动画属性,基于这一点，css3的animation就需要明确的动画属性值，这也就是回到我们上面所说的，我们需要keyframes来定义不同时间的css属性值,达到元素在不同时间段变化的效果。<br>下面我们来看看怎么给一个元素调用animation属性:</p>
<p><pre><code><br>.demo1 {<br>     width: 50px;<br>     height: 50px;<br>     margin-left: 100px;<br>     background: blue;<br>     -webkit-animation-name:’wobble’;/<em>动画属性名，也就是我们前面keyframes定义的动画名</em>/<br>     -webkit-animation-duration: 10s;/<em>动画持续时间</em>/<br>     -webkit-animation-timing-function: ease-in-out; /<em>动画频率，和transition-timing-function是一样的</em>/<br>     -webkit-animation-delay: 2s;/<em>动画延迟时间</em>/<br>     -webkit-animation-iteration-count: 10;/<em>定义循环资料，infinite为无限次</em>/<br>     -webkit-animation-direction: alternate;/<em>定义动画方式</em>/<br>  }<br></code></pre><br>CSS Animation动画效果将会影响元素相对应的css值，在整个动画过程中，元素的变化属性值完全是由animation来控制，动画后面的会覆盖前面的属性值。如上面例子：因为我们这个demo只是在不同的时间段改变了demo1的背景色和左边距，其默认值是：margin-left:100px;background: blue；但当我们在执行动画0%时，margin-left:100px,background:green；当执行到40%时，属性变成了：margin-left:150px;background:orange;当执行到60%时margin-left:75px;background:blue;当动画 执行到100%时：margin-left:100px;background: red;此时动画将完成，那么margin-left和background两个属性值将是以100%时的为主,他不会产生叠加效果，只是一次一次覆盖前一次出将的css属性。就如我们平时的css一样，最后出现的权根是最大的。当动画结束后，样式回到默认效果。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>下面我们一起来看两个实例制作过程，来加强对animation的实践能力。</p>
<p>我们这个demo主要是通过在keyframes中改变元素的background;color;box-shadow三个属性，来达到一种发光变色的button效果。<br><a href="http://codepen.io/shanruo/pen/YyVObE" target="_blank" rel="external">DEMO一</a></p>
<p>DEMO二是通过transform的rotate和border-radius不同值，把一个方型图片随着时间的推移，慢慢的转换成了个圆型效果，下面我们来看看其具体实现的效果。<br><a href="http://codepen.io/shanruo/pen/pjPOMz" target="_blank" rel="external">DEMO二</a></p>
</delay></animation></duration></property></time>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/10/07/css动画/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://shanruo.github.io/2015/10/07/css动画/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/10/07/css动画/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-08-09T05:46:22.000Z"><a href="/2015/08/09/一个完整的基于Node-js的web应用/">Sun, Aug 9 2015, 1:46:22 pm</a></time>

  
    <h1 class="title"><a href="/2015/08/09/一个完整的基于Node-js的web应用/">一个完整的基于Node.js的web应用</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><ul>
<li>用户通过浏览器可以使用该应用</li>
<li>当用户请求<span><a href="http://domain/start" target="_blank" rel="external">http://domain/start</a></span>时，可以看到一个欢迎页面，页面上有一个文件上传的表单</li>
<li>用户可以选择一个图片并提交表单，随后文件将被上传到<span><a href="http://domain/upload" target="_blank" rel="external">http://domain/upload</a></span>，该页面完成上传后会把图片显示在页面上</li>
</ul>
<p>在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。</p>

<h2 id="应用不同模块分析"><a href="#应用不同模块分析" class="headerlink" title="应用不同模块分析"></a>应用不同模块分析</h2><ul>
<li>我们需要提供Web页面，因此需要一个HTTP服务器</li>
<li>对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler）</li>
<li>当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序</li>
<li>路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能</li>
<li>我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器</li>
<li>最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节</li>
</ul>
<p>现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。</p>

<h2 id="构建应用的模块"><a href="#构建应用的模块" class="headerlink" title="构建应用的模块"></a>构建应用的模块</h2><h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><p>当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？<br>实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。<br>那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。<br>让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码:</p>
<p><pre><code><br>var http = require(“http”);<br>var url = require(“url”);<br>function start(route, handle) {<br>    function onRequest(request, response) {<br>        var pathname = url.parse(request.url).pathname;<br>        console.log(“Request for “ + pathname + “ received.”);<br>        route(handle, pathname, response, request);<br>    }<br>    http.createServer(onRequest).listen(8888);<br>    console.log(“Server has started.”);<br>}<br>exports.start = start;<br></code></pre></p>
<h3 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h3><p>我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。</p><p>我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。创建 index.js 文件并写入以下内容：</p>
<p><pre><code>var server = require(“./server”);<br>var router = require(“./router”);<br>var requestHandlers = require(“./requestHandlers”);<br>var handle = {};<br>handle[“/“] = requestHandlers.start;<br>handle[“/start”] = requestHandlers.start;<br>handle[“/upload”] = requestHandlers.upload;<br>handle[“/show”] = requestHandlers.show;<br>server.start(router.route, handle);<br></code></pre></p>
<h3 id="如何来进行请求的“路由”"><a href="#如何来进行请求的“路由”" class="headerlink" title="如何来进行请求的“路由”"></a>如何来进行请求的“路由”</h3><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。<br>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。<br>们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。<br>现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容：</p>
<p><pre><code><br>function route(handle, pathname, response, request) {<br>    console.log(“About to route a request for “ + pathname);<br>    if (typeof handle[pathname] === ‘function’) {<br>        handle<a href="response, request">pathname</a>;<br>    } else {<br>        console.log(“No request handler found for “ + pathname);<br>        response.writeHead(404, {“Content-Type”: “text/html”});<br>        response.write(“404 Not found”);<br>        response.end();<br>    }<br>}<br>exports.route = route;<br></code><pre></pre></pre></p>
<h3 id="路由给真正的请求处理程序"><a href="#路由给真正的请求处理程序" class="headerlink" title="路由给真正的请求处理程序"></a>路由给真正的请求处理程序</h3><p>回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。<br>当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。<br>在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。<br>我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。<br>应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>
<p><pre><code><br>var querystring = require(“querystring”),<br>    fs = require(“fs”),<br>    formidable = require(“formidable”);<br>function start(response) {<br>    console.log(“Request handler ‘start’ was called.”);<br>    var body = ‘&lt;html&gt;’+<br>        ‘&lt;head&gt;’+<br>        ‘&lt;meta http-equiv=”Content-Type” content=”text/html; ‘+<br>        ‘charset=UTF-8” /&gt;’+<br>        ‘&lt;/head&gt;’+<br>        ‘&lt;body&gt;’+<br>        ‘&lt;form action=”/upload” enctype=”multipart/form-data” ‘+<br>        ‘method=”post”&gt;’+<br>        ‘&lt;input type=”file” name=”upload” multiple=”multiple”&gt;’+<br>        ‘&lt;input type=”submit” value=”Upload file” /&gt;’+<br>        ‘&lt;/form&gt;’+<br>        ‘&lt;/body&gt;’+<br>        ‘&lt;/html&gt;’;<br>    response.writeHead(200, {“Content-Type”: “text/html”});<br>    response.write(body);<br>    response.end();<br>}<br>function upload(response, request) {<br>    console.log(“Request handler ‘upload’ was called.”);<br>    var form = new formidable.IncomingForm();<br>    console.log(“about to parse”);<br>    form.parse(request, function(error, fields, files) {<br>        console.log(“parsing done”);<br>        fs.renameSync(files.upload.path, “/tmp/test.png”);<br>        response.writeHead(200, {“Content-Type”: “text/html”});<br>        response.write(“received image:&lt;br/&gt;”);<br>        response.write(“&lt;img src=’/show’ /&gt;”);<br>        response.end();<br>    });<br>}<br>function show(response) {<br>    console.log(“Request handler ‘show’ was called.”);<br>    fs.readFile(“/tmp/test.png”, “binary”, function(error, file) {<br>        if(error) {<br>            response.writeHead(500, {“Content-Type”: “text/plain”});<br>            response.write(error + “\n”);<br>            response.end();<br>        } else {<br>            response.writeHead(200, {“Content-Type”: “image/png”});<br>            response.write(file, “binary”);<br>            response.end();<br>        }<br>    });<br>}<br>exports.start = start;<br>exports.upload = upload;<br>exports.show = show;<br></code></pre><br>这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。<br>好了，启动服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。</p>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。接下来是不是对node.js越来越感兴趣了，反正我是深深的爱上了他，么么哒ლ(°◕‵ƹ′◕ლ)!</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/08/09/一个完整的基于Node-js的web应用/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://shanruo.github.io/2015/08/09/一个完整的基于Node-js的web应用/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/08/09/一个完整的基于Node-js的web应用/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js"></script>
<script src="/js/cover.js"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2017 shanruo
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"shanruo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>